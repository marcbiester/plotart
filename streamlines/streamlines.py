import numpy as np
import matplotlib.pyplot as plt
from scipy import interpolate


class streamLines:
    def __init__(self, grid):
        self.x = []
        self.y = []
        self.dx = []
        self.dy = []
        self.X = []
        self.Y = []
        self.psis = []
        self.streamtraces=[]
        self.grid = grid
        grid_shape = (grid['no_points_x'], grid['no_points_y'])
        self.psi = np.zeros(grid_shape)
        self.u = np.zeros(grid_shape)
        self.v = np.zeros(grid_shape)
        self.generate_mesh()


    def generate_mesh(self):
        self.x = np.linspace(self.grid["x_start"], self.grid["x_end"], self.grid["no_points_x"])
        self.y = np.linspace(self.grid["y_start"], self.grid["y_end"], self.grid["no_points_y"])
        self.dx = (self.grid["x_end"] - self.grid["x_start"]) / self.grid["no_points_x"]
        self.dy = (self.grid["y_end"] - self.grid["y_start"]) / self.grid["no_points_y"]
        self.X, self.Y = np.meshgrid(self.x, self.y)

    def add_source_sink(self, strength, x, y):
        """
        Returns the stream-function generated by a source/sink.

        Parameters
        ----------
        strength: float
            Strength of the source/sink.
        x: float
            x-coordinate of the source (or sink).
        y: float
            y-coordinate of the source (or sink).

        Returns
        -------
        psi: 2D Numpy array of floats
            The stream-function.
        """
        psi = strength / (2 * np.pi) * np.arctan2((self.Y - y), (self.X - x))
        self.psis.append(psi)
        self.psi = np.add(self.psi, psi)
        self.u = self.u + (
            strength
            / (2 * np.pi)
            * (self.X - x)
            / ((self.X - x) ** 2 + (self.Y - y) ** 2)
        )
        self.v = self.v + (
            strength
            / (2 * np.pi)
            * (self.Y - y)
            / ((self.X - x) ** 2 + (self.Y - y) ** 2)
        )

    def add_free_stream(self, u_inf=0, v_inf=0):
        psi = u_inf * self.Y - v_inf * self.X
        self.psis.append(psi)
        self.psi = np.add(self.psi, psi)
        self.u = self.u + u_inf
        self.v = self.v + v_inf

    def add_doublet(self, strength, x, y):
        """
        Returns the stream-function generated by a doublet.

        Parameters
        ----------
        strength: float
            Strength of the doublet.
        x: float
            x-coordinate of the doublet.
        y: float
            y-coordinate of the doublet.

        Returns
        -------
        psi: 2D Numpy array of floats
            The stream-function.
        """
        psi = (
            -strength
            / (2 * np.pi)
            * (self.Y - y)
            / ((self.X - x) ** 2 + (self.Y - y) ** 2)
        )
        self.psis.append(psi)
        self.psi = np.add(self.psi, psi)
        self.u = self.u - (
            strength
            / (2 * np.pi)
            * ((self.X - x) ** 2 - (self.Y - y) ** 2)
            / ((self.X - x) ** 2 + (self.Y - y) ** 2) ** 2
        )
        self.v = self.v - (
            strength
            / (2 * np.pi)
            * 2
            * (self.X - x)
            * (self.Y - y)
            / ((self.X - x) ** 2 + (self.Y - y) ** 2) ** 2
        )

    def add_vortex(self, strength, x, y):
        """
        Returns the velocity field generated by a vortex.

        Parameters
        ----------
        strength: float
            Strength of the vortex.
        xv: float
            x-coordinate of the vortex.
        yv: float
            y-coordinate of the vortex.
        X: 2D Numpy array of floats
            x-coordinate of the mesh points.
        Y: 2D Numpy array of floats
            y-coordinate of the mesh points.
        """
        psi = strength / (4 * np.pi) * np.log((self.X - x) ** 2 + (self.Y - y) ** 2)
        self.psis.append(psi)
        self.psi = np.add(self.psi, psi)
        self.u = self.u + strength / (2 * np.pi) * (self.Y - y) / (
            (self.X - x) ** 2 + (self.Y - y) ** 2
        )
        self.v = self.v - strength / (2 * np.pi) * (self.X - x) / (
            (self.X - x) ** 2 + (self.Y - y) ** 2
        )

    def reset_psi(self):
        self.psi = self.psis[0]
        if len(self.psis > 0):
            for i in range(1, len(self.psis)):
                self.psi = np.add(self.psi, self.psis[i])
    
    
    def _point_in_range(self, point):
        if point[0] < self.grid['x_start'] or point[0] > self.grid['x_end'] or \
            point[1] < self.grid['y_start'] or point[1] > self.grid['y_end']:
            return False
        else:
            return True

    
    def calc_streamtraces(self, n_streamtraces=10, dt=0.01, maxiter=200):
        u_i=interpolate.interp2d(self.x, self.y, self.u)
        v_i=interpolate.interp2d(self.x, self.y, self.v)
        
        for trace in range(n_streamtraces):
            p=[np.random.uniform(self.grid['x_start'], self.grid['x_end']), np.random.uniform(self.grid['y_start'], self.grid['y_end'])]
            ps=[]
            n=0
            while self._point_in_range(p) and n <= maxiter:
                ps.append(p.copy())
                dx=u_i(p[0], p[1])[0]*dt
                dy=v_i(p[0], p[1])[0]*dt
                p[0]=p[0]+dx
                p[1]=p[1]+dy
                n+=1
            self.streamtraces.append(ps)



    
    
    def plot(self, num_level=25, legend=True):
        fig, ax = plt.subplots(figsize=(12, 10))
        c = ax.contour(self.x, self.y, self.psi, num_level)
        if legend:
            fig.colorbar(c, ax=ax, shrink=0.9)
    

