import matplotlib.pyplot as plt
from shapely.geometry import MultiLineString
import numpy as np
import sys
import tqdm as tq
from plotart.streamlines.streamlinesgpt import StreamLines
from plotart.rectangles.rect import RectanglePacker

import logging

logging.getLogger('numba').setLevel(logging.ERROR)

def create_random_config(
    grid,
    n_vort=-1,
    n_source_sink=-1,
    v_strength=50,
    ss_strength=5,
    n_streamtraces=-1,
    seed_setting=None,
    max_iter=-1,
    seed_radius=-1,
    max_sink_dist=-1,
):
    if seed_setting is None:
        seed_setting = []

    # Random defaults if negative
    n_streamtraces = np.random.randint(50, 200) if n_streamtraces < 0 else n_streamtraces
    max_iter = np.random.randint(200, 1500) if max_iter < 0 else max_iter
    max_sink_dist = np.random.uniform(0.5, 3.0) if max_sink_dist < 0 else max_sink_dist
    seed_radius = np.random.uniform(0.2, 1.0) if seed_radius < 0 else seed_radius

    if n_vort < 0:
        n_vort = np.random.randint(1, 20)
    if n_source_sink < 0:
        n_source_sink = np.random.randint(1, 20)

    if not seed_setting:
        possible_modes = ["random", "sources", "grid"]
        n_modes = np.random.randint(1, 4)
        chosen_modes = np.random.choice(possible_modes, n_modes, replace=False)
        seed_setting = chosen_modes.tolist()

    params = {
        "n_streamtraces": n_streamtraces,
        "max_iter": max_iter,
        "vortices": [],
        "source_sink": [],
        "seed_setting": seed_setting,
        "seed_radius": seed_radius,
        "max_sink_dist": max_sink_dist,
    }

    # Generate vortices and corresponding source/sink
    for _ in range(n_vort):
        x = np.random.uniform(grid["x_start"], grid["x_end"])
        y = np.random.uniform(grid["y_start"], grid["y_end"])
        vortex_strength = np.random.uniform(-v_strength, v_strength)
        source_sink_strength = np.random.uniform(-ss_strength, ss_strength)
        if abs(source_sink_strength) < 3:
            source_sink_strength = (source_sink_strength / abs(source_sink_strength)) * 5
        params["vortices"].append((vortex_strength, x, y))
        params["source_sink"].append((source_sink_strength, x, y))

    # Generate additional source/sinks
    for _ in range(n_source_sink):
        x = np.random.uniform(grid["x_start"], grid["x_end"])
        y = np.random.uniform(grid["y_start"], grid["y_end"])
        source_sink_strength = np.random.uniform(-ss_strength, ss_strength)
        params["source_sink"].append((source_sink_strength, x, y))

    return params


def show_multiple_attempts(attempts, rows=2, cols=3):
    """
    Show multiple attempts side by side.
    attempts: list of (streamlines, config) tuples, where streamlines is a list of traces.
    Returns the index of the chosen attempt, or None if none chosen.
    """
    fig, axes = plt.subplots(rows, cols, figsize=(12, 8))
    axes = axes.flatten()

    for i, (traces, data) in enumerate(attempts):
        ax = axes[i]
        grid = data["grid"]
        for trace in traces:
            xs = [pt[0] for pt in trace]
            ys = [pt[1] for pt in trace]
            ax.plot(xs, ys)
        ax.set_title(f"Attempt {i+1}")
        ax.set_aspect('equal', 'box')
        ax.set_xlim(grid["x_start"], grid["x_end"])
        ax.set_ylim(grid["y_start"], grid["y_end"])

    # Hide extra axes if attempts < rows*cols
    for j in range(len(attempts), rows*cols):
        axes[j].axis('off')

    # Add instruction text
    fig.suptitle("Click on a subplot to select that attempt.\nClose the window if you don't like any.", fontsize=14)

    chosen_index = [None]  # mutable closure variable

    def on_click(event):
        if event.inaxes in axes:
            chosen_ax = event.inaxes
            chosen_idx = np.where(axes == chosen_ax)[0][0]
            if chosen_idx < len(attempts):
                chosen_index[0] = chosen_idx
                plt.close(fig)

    cid = fig.canvas.mpl_connect('button_press_event', on_click)
    plt.tight_layout(rect=[0, 0, 1, 0.94])  # leave space for suptitle
    plt.show()

    return chosen_index[0]


def generate(
    interactive=True,
    max_attempts_per_rect=10,
    attempts_per_batch=6,
    max_retries_for_full_batch=5,
    random_scaling=True,          # New parameter for optional random scaling
    num_rectangles=6             # New parameter to set the number of rectangles
):
    """
    Generate a MultiLineString.
    If interactive=True:
      - For each rectangle, generate a batch of attempts.
      - Display all attempts and let the user pick one by clicking on its subplot.
      - Random scaling can be toggled by `random_scaling`.
      - The number of rectangles generated by the packer can be set via `num_rectangles`.
    """
    rect_target = {"x": 0, "y": 0, "h": 30, "w": 42}
    packer = RectanglePacker(rect_target)

    # Use the specified number of rectangles
    rect_sources = packer.generate_random_rectangles(num_rectangles, [3, 10], [3, 10])
    solution = packer.optimize_rectangles(rect_sources)

    ms = []

    for rect in tq.tqdm(solution):
        grid = {
            "x_start": 0,
            "x_end": solution[rect]["w"] * 10,
            "y_start": 0,
            "y_end": solution[rect]["h"] * 10,
            "no_points_x": 100,
            "no_points_y": 100,
        }

        chosen = False
        rect_attempts_done = 0

        while rect_attempts_done < max_attempts_per_rect and not chosen:
            rect_attempts_done += 1

            # Try to get a full batch of attempts_per_batch attempts
            attempts = []
            for _ in range(max_retries_for_full_batch):
                attempts = []
                for _ in range(attempts_per_batch):
                    try:
                        sl = StreamLines(grid)
                        config = create_random_config(
                            grid=grid,
                            n_streamtraces=-1,
                            max_iter=-1,
                            seed_setting=[],
                            n_source_sink=-1,
                        )
                        # Add sources/sinks and vortices
                        for source_sink in config["source_sink"]:
                            sl.add_source_sink(*source_sink)
                        for vortex in config["vortices"]:
                            sl.add_vortex(*vortex)

                        dt = (solution[rect]["w"] * solution[rect]["h"]) / 1e3
                        sl.calc_streamtraces(
                            n_streamtraces=config["n_streamtraces"],
                            seeds=config["seed_setting"],
                            dt=dt,
                            maxiter=config["max_iter"],
                            radius=config["seed_radius"],
                            max_sink_dist=config["max_sink_dist"],
                            n_cpu=12,
                        )

                        # Keep only attempts that have at least some valid lines
                        valid_streams = [z for z in sl.streamtraces if len(z) > 2]
                        if valid_streams:
                            attempts.append((valid_streams, {"grid": grid, "config": config}))
                    except Exception:
                        pass

                if len(attempts) == 0:
                    # No valid attempts at all in this retry, try again
                    continue
                else:
                    # We got some attempts (not necessarily full)
                    break

            if not attempts:
                # Couldn't get any attempts even after multiple retries
                # Move on to next rectangle
                break

            # Show the attempts to the user
            if interactive:
                chosen_idx = show_multiple_attempts(attempts)
            else:
                # If not interactive, pick the first attempt
                chosen_idx = 0 if attempts else None

            if chosen_idx is not None:
                chosen = True
                # Add the chosen attempt to the final MultiLineString
                chosen_streamtraces, chosen_data = attempts[chosen_idx]
                for z in chosen_streamtraces:
                    if random_scaling:
                        border = -0.1 + 0.2 * np.random.rand()
                        x_mult = (1 - border)
                        y_mult = (1 - border)
                        x_offset = solution[rect]["x"] * 10 + border
                        y_offset = solution[rect]["y"] * 10 + border
                    else:
                        # No random scaling, just translate based on rect coords
                        border = 0.0
                        x_mult = 1.0
                        y_mult = 1.0
                        x_offset = solution[rect]["x"] * 10
                        y_offset = solution[rect]["y"] * 10

                    streamtrace = [
                        (
                            x * x_mult + x_offset,
                            y * y_mult + y_offset,
                        )
                        for x, y in z
                    ]
                    ms.append(streamtrace)
            # If user didn't choose (closed figure), we try another batch until max_attempts_per_rect

    return MultiLineString(ms)


if __name__ == "__main__":
    # Example usage:
    # interactive=True for user interaction,
    # random_scaling=False to disable random scaling,
    # num_rectangles=30 to only generate 30 rectangles instead of 50
    mls = generate(
        # All parameters must be set as defaults in the function as
        # vpype is ignoring them otherwiee
        # interactive=True,
        # max_attempts_per_rect=5,
        # attempts_per_batch=6,
        # max_retries_for_full_batch=3,
        # random_scaling=False,
        # num_rectangles=6
    )

    plt.figure()
    for ls in mls:
        plt.plot(*ls.xy, "-", color="k", linewidth=0.1)
    plt.axis("equal")
    plt.title("Final Selected Streamlines")
    plt.show()
